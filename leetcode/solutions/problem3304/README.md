LeetCode 3304 "Find the K-th Character in String Game I"
---

### **Algorithm Analysis: Find the K-th Character in String Game I**

This problem describes a string generation process where, starting with `"a"`, a new string is formed by taking the current string, applying a character-to-next-character shift, and appending the shifted version to the original. This operation is repeated infinitely. We need to find the $k$-th character (1-indexed) in this infinitely growing string.

Let's observe the string generation:
* $S_0 = \text{"a"}$ (length $1 = 2^0$)
* $S_1 = S_0 + \text{shift}(S_0) = \text{"a"} + \text{"b"} = \text{"ab"}$ (length $2 = 2^1$)
* $S_2 = S_1 + \text{shift}(S_1) = \text{"ab"} + \text{"bc"} = \text{"abbc"}$ (length $4 = 2^2$)
* $S_3 = S_2 + \text{shift}(S_2) = \text{"abbc"} + \text{"bccd"} = \text{"abbcbccd"}$ (length $8 = 2^3$)

Generalizing, the string at step $n$, $S_n$, has a length of $2^n$, and is formed by concatenating $S_{n-1}$ with a version of $S_{n-1}$ where every character has been shifted to its next alphabetical character (`a` becomes `b`, `b` becomes `c`, ..., `z` becomes `a`).

#### **Core Idea: Binary Search on String Structure**

The problem's structure is recursive and self-similar. Each string $S_n$ is composed of $S_{n-1}$ followed by a shifted $S_{n-1}$. This allows us to use a binary search-like approach to locate the $k$-th character. At each step, we determine if the target character `k` falls into the first half (the unshifted $S_{n-1}$) or the second half (the shifted $S_{n-1}$). If it falls into the second half, we adjust `k` relative to that half and increment a `shift` counter, as every character in that half is one step further along the alphabet.

#### **Step-by-Step Algorithm**

1.  **Determine the Relevant String Length:**
    * `length = 1`: Start with the length of $S_0$.
    * `while length < k: length *= 2`: This loop finds the smallest power of 2 (which is the length of some $S_P$) that is greater than or equal to `k`. This `length` now represents $S_P$, the smallest string in the sequence that contains the $k$-th character.

2.  **Locate Character and Accumulate Shift:**
    * `shift = 0`: This variable will accumulate the total alphabetical shift that needs to be applied to the base character 'a' to find the final character.
    * `while length > 1:`: This loop iteratively halves the `length` until we reach the base case (`length = 1`, representing the "a" at the core).
        * `if k > length // 2:`: If `k` falls into the second half of the current string segment (i.e., the portion that was generated by shifting the previous segment):
            * `shift += 1`: Increment `shift` because this part of the string has undergone an additional alphabetical shift.
            * `k -= length // 2`: Adjust `k` to be its position relative to the beginning of this second half.
        * `length //= 2`: Halve the `length` for the next iteration, effectively moving to the previous string generation step (e.g., from $S_P$ to $S_{P-1}$).

3.  **Calculate the Final Character:**
    * `return chr(ord('a') + (k - 1 + shift) % 26)`:
        * `k - 1`: `k` is 1-indexed, so `k-1` converts it to a 0-indexed position. At the end of the `while` loop, `k` will be `1` (or `0` if it started as `1` and was never in the shifted half). Effectively, `k-1` represents the 0-indexed position relative to the *initial* 'a' before any shifts.
        * `+ shift`: Add the accumulated `shift` value to this base position. This `shift` tells us how many times the character at this position has been transformed ('a' -> 'b', 'b' -> 'c', etc.).
        * `% 26`: Apply the modulo 26 operation to handle wrapping around the alphabet (e.g., 'z' shifted becomes 'a').
        * `chr(ord('a') + ...)`: Convert the final numerical shift back to a character.

#### **Example Trace (`k = 5`)**

* **Initial:** `k = 5`
* **First Loop:**
    * `length = 1`
    * `1 < 5` -> `length = 2`
    * `2 < 5` -> `length = 4`
    * `4 < 5` -> `length = 8`. (`length` is now $2^3$, the length of $S_3 = \text{"abbcbccd"}$)
* **Second Loop:**
    * `length = 8`, `shift = 0`
    * **Iteration 1:** (`length = 8`)
        * `k = 5`. `length // 2 = 4`. `k > length // 2` (5 > 4) is True.
            * `shift = 1`.
            * `k = 5 - 4 = 1`. (We are now looking for the 1st character in the *shifted* part of $S_2$, which is "bccd").
        * `length = 4`.
    * **Iteration 2:** (`length = 4`)
        * `k = 1`. `length // 2 = 2`. `k > length // 2` (1 > 2) is False. (We are now looking for the 1st character in the *unshifted* part of $S_1$, which is "ab").
        * `length = 2`.
    * **Iteration 3:** (`length = 2`)
        * `k = 1`. `length // 2 = 1`. `k > length // 2` (1 > 1) is False. (We are now looking for the 1st character in the *unshifted* part of $S_0$, which is "a").
        * `length = 1`.
    * Loop ends (`length` is no longer greater than 1).
* **Final Calculation:**
    * `k = 1`, `shift = 1`
    * `chr(ord('a') + (1 - 1 + 1) % 26) = chr(ord('a') + 1) = 'b'`
    * The 5th character of `S_3` ("abbcbccd") is indeed 'b'.

#### **Complexity Analysis**

* **Time Complexity: $O(\log k)$**
    * The first `while` loop runs `log k` times, as `length` doubles in each step until it reaches `k`.
    * The second `while` loop also runs `log k` times, as `length` is halved in each step until it reaches `1`.
    * All operations within the loops are constant time.
    * Therefore, the total time complexity is logarithmic with respect to `k`.

* **Space Complexity: $O(1)$**
    * The algorithm uses only a few constant variables (`length`, `k`, `shift`).
    * It does not allocate any additional data structures whose size scales with `k`.

#### **Advantages of this Algorithm**

* **Optimal Time Complexity:** Achieves an $O(\log k)$ runtime, which is highly efficient for potentially very large values of `k`.
* **Constant Space:** Uses a minimal amount of auxiliary memory.
* **Elegant Use of Recursion (Implicitly):** The iterative solution effectively simulates the recursive structure of the string generation without incurring explicit recursion overhead.
